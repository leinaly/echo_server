DEPRECATION WARNING: Initialization autoloaded the constants BaseAPI and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload BaseAPI, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants BaseAPI and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload BaseAPI, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.1ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
{"method":"GET","path":"/","format":"html","controller":"Rails::WelcomeController","action":"index","status":200,"allocations":4441,"duration":26.97,"view":13.9,"db":0.0,"time":6052297.138094,"host":"Hannas-MacBook-Pro.local","user_id":null,"api_key":null,"params":{},"@timestamp":"2024-09-26T10:32:37.257Z","@version":"1","message":"[200] GET / (Rails::WelcomeController#index)"}
  
ActionController::RoutingError (No route matches [GET] "/favicon.ico"):
  
  
ActionController::RoutingError (No route matches [GET] "/routes"):
  
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.8ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
  [1m[35m (0.6ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" varchar NOT NULL PRIMARY KEY)[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" varchar NOT NULL PRIMARY KEY, "value" varchar, "created_at" datetime(6) NOT NULL, "updated_at" datetime(6) NOT NULL)[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
Migrating to CreateApiKeys (20240927144755)
  [1m[36mTRANSACTION (0.0ms)[0m  [1m[36mbegin transaction[0m
  [1m[35m (0.2ms)[0m  [1m[35mCREATE TABLE "api_keys" ("id" integer PRIMARY KEY AUTOINCREMENT NOT NULL, "access_token" varchar, "name" varchar, "created_at" datetime(6) NOT NULL, "updated_at" datetime(6) NOT NULL)[0m
  [1m[35m (0.0ms)[0m  [1m[35mCREATE INDEX "index_api_keys_on_access_token" ON "api_keys" ("access_token")[0m
  [1m[36mActiveRecord::SchemaMigration Create (0.0ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES (?)[0m  [["version", "20240927144755"]]
  [1m[36mTRANSACTION (0.5ms)[0m  [1m[36mcommit transaction[0m
Migrating to CreateEndpoints (20240927144808)
  [1m[35m (0.3ms)[0m  [1m[34mSELECT sqlite_version(*)[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
Migrating to CreateEndpoints (20240927144808)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (209.9ms)[0m  [1m[35mCREATE DATABASE "echo_server_development" ENCODING = 'unicode'[0m
  [1m[35m (81.1ms)[0m  [1m[35mCREATE DATABASE "echo_server_test" ENCODING = 'unicode'[0m
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (15.0ms)[0m  [1m[35mCREATE TABLE "schema_migrations" ("version" character varying NOT NULL PRIMARY KEY)[0m
  [1m[35m (1.7ms)[0m  [1m[35mCREATE TABLE "ar_internal_metadata" ("key" character varying NOT NULL PRIMARY KEY, "value" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT pg_try_advisory_lock(3934162957180876140)[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
Migrating to CreateApiKeys (20240927144755)
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.8ms)[0m  [1m[35mCREATE TABLE "api_keys" ("id" bigserial primary key, "access_token" character varying, "name" character varying, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE INDEX "index_api_keys_on_access_token" ON "api_keys" ("access_token")[0m
  [1m[36mActiveRecord::SchemaMigration Create (0.2ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20240927144755"]]
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mCOMMIT[0m
Migrating to CreateEndpoints (20240927144808)
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[35m (1.1ms)[0m  [1m[35mCREATE TABLE "endpoints" ("id" bigserial primary key, "verb" character varying, "path" character varying, "response_code" integer, "response_headers" jsonb, "response_body" text, "created_at" timestamp(6) NOT NULL, "updated_at" timestamp(6) NOT NULL)[0m
  [1m[35m (0.4ms)[0m  [1m[35mCREATE INDEX "index_endpoints_on_path" ON "endpoints" ("path")[0m
  [1m[36mActiveRecord::SchemaMigration Create (0.1ms)[0m  [1m[32mINSERT INTO "schema_migrations" ("version") VALUES ($1) RETURNING "version"[0m  [["version", "20240927144808"]]
  [1m[36mTRANSACTION (0.3ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mActiveRecord::InternalMetadata Load (0.3ms)[0m  [1m[34mSELECT "ar_internal_metadata".* FROM "ar_internal_metadata" WHERE "ar_internal_metadata"."key" = $1 LIMIT $2[0m  [["key", "environment"], ["LIMIT", 1]]
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mActiveRecord::InternalMetadata Create (0.5ms)[0m  [1m[32mINSERT INTO "ar_internal_metadata" ("key", "value", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "key"[0m  [["key", "environment"], ["value", "development"], ["created_at", "2024-09-27 14:59:43.415442"], ["updated_at", "2024-09-27 14:59:43.415442"]]
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.1ms)[0m  [1m[34mSELECT pg_advisory_unlock(3934162957180876140)[0m
  [1m[35m (0.3ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (7.9ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
{"method":"GET","path":"/","format":"html","controller":"Rails::WelcomeController","action":"index","status":200,"allocations":3285,"duration":7.71,"view":5.09,"db":0.0,"time":6158436.588521,"host":"Hannas-MacBook-Pro.local","user_id":null,"api_key":null,"params":{},"@timestamp":"2024-09-27T16:01:36.926Z","@version":"1","message":"[200] GET / (Rails::WelcomeController#index)"}
  
ActionController::RoutingError (No route matches [GET] "/api/endpoints"):
  
  
ActionController::RoutingError (No route matches [GET] "/api"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/endpoint"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/endpoints"):
  
  
ActionController::RoutingError (No route matches [GET] "/api"):
  
  
ActionController::RoutingError (No route matches [GET] "/api"):
  
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.7ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  
ActionController::RoutingError (No route matches [GET] "/api/status"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/status"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/swagger_doc"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/v1"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/v1/endpoints"):
  
  
ActionController::RoutingError (No route matches [GET] "/v1/api/endpoints"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/endpoints"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/status"):
  
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (15.4ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  
ActionController::RoutingError (No route matches [GET] "/api/status"):
  
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  
ActionController::RoutingError (No route matches [GET] "/api/v1/status"):
  
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
{"method":"GET","path":"/","format":"html","controller":"Rails::WelcomeController","action":"index","status":200,"allocations":3285,"duration":6.94,"view":4.08,"db":0.0,"time":759.393368,"host":"Hannas-MacBook-Pro.local","user_id":null,"api_key":null,"params":{},"@timestamp":"2024-09-30T14:13:11.312Z","@version":"1","message":"[200] GET / (Rails::WelcomeController#index)"}
  
ActionController::RoutingError (No route matches [GET] "/favicon.ico"):
  
  
ActionController::RoutingError (No route matches [GET] "/routes"):
  
  
ActionController::RoutingError (No route matches [GET] "/api"):
  
  
ActionController::RoutingError (No route matches [GET] "/api/endpoints"):
  
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  
ActionController::RoutingError (No route matches [GET] "/api/status"):
  
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  
ActionController::RoutingError (No route matches [GET] "/api/status"):
  
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  
ActionController::RoutingError (No route matches [GET] "/api/status"):
  
  [1m[36mEndpoint Load (1.9ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/api/endpoints_api.rb:10:in `block (2 levels) in <class:API>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.8ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mEndpoint Load (0.7ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/endpoints_api.rb:10:in `block (2 levels) in <class:API>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.9ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mEndpoint Load (3.5ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/endpoints_api.rb:10:in `block (2 levels) in <class:API>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.8ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mApiKey Load (1.8ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys"[0m
  [1m[36mEndpoint Load (1.0ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mBEGIN[0m
  [1m[36mApiKey Exists? (0.9ms)[0m  [1m[34mSELECT 1 AS one FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "141336a6dde2bd0e6670d260bad713c84e15dcf8"], ["LIMIT", 1]]
  [1m[36mApiKey Create (2.1ms)[0m  [1m[32mINSERT INTO "api_keys" ("access_token", "name", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["access_token", "141336a6dde2bd0e6670d260bad713c84e15dcf8"], ["name", "Test Client 1"], ["created_at", "2024-10-01 14:27:09.848403"], ["updated_at", "2024-10-01 14:27:09.848403"]]
  [1m[36mTRANSACTION (0.9ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mApiKey Exists? (0.2ms)[0m  [1m[34mSELECT 1 AS one FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  [1m[36mApiKey Create (0.2ms)[0m  [1m[32mINSERT INTO "api_keys" ("access_token", "name", "created_at", "updated_at") VALUES ($1, $2, $3, $4) RETURNING "id"[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["name", "Test Client 2"], ["created_at", "2024-10-01 14:27:09.853649"], ["updated_at", "2024-10-01 14:27:09.853649"]]
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (2.6ms)[0m  [1m[34mSELECT COUNT(*) FROM "api_keys"[0m
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEndpoint Exists? (0.2ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE "endpoints"."path" = $1 LIMIT $2[0m  [["path", "/hello"], ["LIMIT", 1]]
  [1m[36mEndpoint Create (1.6ms)[0m  [1m[32mINSERT INTO "endpoints" ("verb", "path", "response_code", "response_headers", "response_body", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["verb", "GET"], ["path", "/hello"], ["response_code", 200], ["response_headers", "\"---\\nContent-Type: application/json\\n\""], ["response_body", "{ \"message\": \"Hello, world!\" }"], ["created_at", "2024-10-01 14:27:09.863202"], ["updated_at", "2024-10-01 14:27:09.863202"]]
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEndpoint Exists? (0.2ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE "endpoints"."path" = $1 LIMIT $2[0m  [["path", "/submit"], ["LIMIT", 1]]
  [1m[36mEndpoint Create (0.2ms)[0m  [1m[32mINSERT INTO "endpoints" ("verb", "path", "response_code", "response_headers", "response_body", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["verb", "POST"], ["path", "/submit"], ["response_code", 201], ["response_headers", "\"---\\nContent-Type: application/json\\n\""], ["response_body", "{ \"message\": \"Data submitted successfully!\" }"], ["created_at", "2024-10-01 14:27:09.867574"], ["updated_at", "2024-10-01 14:27:09.867574"]]
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEndpoint Exists? (0.2ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE "endpoints"."path" = $1 LIMIT $2[0m  [["path", "/update"], ["LIMIT", 1]]
  [1m[36mEndpoint Create (0.2ms)[0m  [1m[32mINSERT INTO "endpoints" ("verb", "path", "response_code", "response_headers", "response_body", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["verb", "PATCH"], ["path", "/update"], ["response_code", 200], ["response_headers", "\"---\\nContent-Type: application/json\\n\""], ["response_body", "{ \"message\": \"Data updated successfully!\" }"], ["created_at", "2024-10-01 14:27:09.869918"], ["updated_at", "2024-10-01 14:27:09.869918"]]
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  [1m[36mEndpoint Exists? (0.2ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE "endpoints"."path" = $1 LIMIT $2[0m  [["path", "/delete"], ["LIMIT", 1]]
  [1m[36mEndpoint Create (0.2ms)[0m  [1m[32mINSERT INTO "endpoints" ("verb", "path", "response_code", "response_body", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6) RETURNING "id"[0m  [["verb", "DELETE"], ["path", "/delete"], ["response_code", 204], ["response_body", ""], ["created_at", "2024-10-01 14:27:09.872416"], ["updated_at", "2024-10-01 14:27:09.872416"]]
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mCOMMIT[0m
  [1m[35m (0.2ms)[0m  [1m[34mSELECT COUNT(*) FROM "endpoints"[0m
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.0ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mEndpoint Load (1.9ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/endpoints_api.rb:10:in `block (2 levels) in <class:API>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, BaseAPI, and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (3.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mEndpoint Load (0.7ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/endpoints_api.rb:10:in `block (2 levels) in <class:API>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError and EndpointsAPI.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  
ActionController::RoutingError (No route matches [GET] "/api/api/endpoints"):
  
  [1m[36mEndpoint Load (2.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/endpoints_api.rb:10:in `block (2 levels) in <class:API>'
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constant CustomError.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

This autoloaded constant has been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (3.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
{"method":"GET","path":"/","format":"html","controller":"Rails::WelcomeController","action":"index","status":200,"allocations":3278,"duration":7.2,"view":4.24,"db":0.0,"time":264186.327813,"host":"Hannas-MacBook-Pro.local","user_id":null,"api_key":null,"params":{},"@timestamp":"2024-10-03T15:23:37.813Z","@version":"1","message":"[200] GET / (Rails::WelcomeController#index)"}
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
{"method":"GET","path":"/","format":"html","controller":"Rails::WelcomeController","action":"index","status":200,"allocations":963,"duration":5.1,"view":4.22,"time":438215.467417,"host":"Hannas-MacBook-Pro.local","user_id":null,"api_key":null,"params":{},"@timestamp":"2024-10-05T15:44:06.739Z","@version":"1","message":"[200] GET / (Rails::WelcomeController#index)"}
  
ActionController::RoutingError (No route matches [GET] "/favicon.ico"):
  
  
ActionController::RoutingError (No route matches [GET] "/endpoints"):
  
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.2ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mEndpoint Load (2.6ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/endpoints/index.rb:10:in `block in <class:Index>'
  
ActionController::RoutingError (No route matches [GET] "/hello"):
  
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.6ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  
ActionController::RoutingError (No route matches [GET] "/hello"):
  
  [1m[36mEndpoint Load (2.1ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/hello"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:25:in `block in <class:Root>'
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mBEGIN[0m
  ↳ app/services/create.rb:13:in `call'
  [1m[36mEndpoint Exists? (0.4ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE "endpoints"."path" = $1 LIMIT $2[0m  [["path", "/greeting"], ["LIMIT", 1]]
  ↳ app/services/create.rb:13:in `call'
  [1m[36mEndpoint Create (1.2ms)[0m  [1m[32mINSERT INTO "endpoints" ("verb", "path", "response_code", "response_headers", "response_body", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["verb", "GET"], ["path", "/greeting"], ["response_code", 200], ["response_headers", "{\"Content-Type\":\"application/json\"}"], ["response_body", "{ \"message\": \"Hello, world!\" }"], ["created_at", "2024-10-05 15:49:59.925529"], ["updated_at", "2024-10-05 15:49:59.925529"]]
  ↳ app/services/create.rb:13:in `call'
  [1m[36mTRANSACTION (0.6ms)[0m  [1m[35mCOMMIT[0m
  ↳ app/services/create.rb:13:in `call'
  
ActionController::RoutingError (No route matches [GET] "/greeting"):
  
  [1m[36mEndpoint Load (1.1ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/greeting"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:25:in `block in <class:Root>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mEndpoint Load (0.9ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/api/hello"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:26:in `block in <class:Root>'
  [1m[36mEndpoint Load (4.1ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/hello"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:26:in `block in <class:Root>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/api/endpoints"], ["verb", "POST"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:26:in `block in <class:Root>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[36mApiKey Load (1.0ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys"[0m
  [1m[36mApiKey Load (1.1ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" ORDER BY "api_keys"."id" DESC LIMIT $1[0m  [["LIMIT", 1]]
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  
NoMethodError (undefined method `before' for #<Module:0x000000011dacd730>):
  
app/api/concerns/authentication.rb:7:in `block in <module:Authentication>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  
NoMethodError (undefined method `before' for #<Module:0x000000011b8211f0>):
  
app/api/concerns/authentication.rb:7:in `block in <module:Authentication>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.7ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  
NoMethodError (undefined method `helpers' for #<Module:0x000000011702de70>):
  
app/api/concerns/authentication.rb:7:in `block in <module:Authentication>'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.1ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mApiKey Load (0.8ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:21:in `valid_api_key?'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, Constants::Endpoints, ApplicationRecord, and Endpoint.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.8ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mApiKey Load (0.9ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants CustomError, Constants, and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload CustomError, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[36mApiKey Load (1.9ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" ORDER BY "api_keys"."id" DESC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[36mApiKey Load (1.4ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" ORDER BY "api_keys"."id" DESC LIMIT $1[0m  [["LIMIT", 1]]
  [1m[35m (0.7ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mApiKey Load (1.0ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (1.8ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/api/endpoints"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:48:in `block in <class:Root>'
  [1m[36mApiKey Load (0.4ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.4ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/serializers/endpoint.rb:7:in `represent'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mApiKey Load (0.4ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.5ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/serializers/endpoint.rb:7:in `represent'
  [1m[36mApiKey Load (0.5ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.4ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/hello"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:48:in `block in <class:Root>'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/greetings"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:48:in `block in <class:Root>'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/greeting"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:48:in `block in <class:Root>'
  [1m[36mApiKey Load (0.5ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Exists? (1.6ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE (UPPER(verb) = 'GET' AND LOWER(path) = '/test_create') LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/services/create.rb:44:in `validate_ep_already_exist'
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  ↳ app/services/create.rb:16:in `call'
  [1m[36mEndpoint Exists? (0.3ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE "endpoints"."path" = $1 LIMIT $2[0m  [["path", "/test_create"], ["LIMIT", 1]]
  ↳ app/services/create.rb:16:in `call'
  [1m[36mEndpoint Create (1.3ms)[0m  [1m[32mINSERT INTO "endpoints" ("verb", "path", "response_code", "response_headers", "response_body", "created_at", "updated_at") VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING "id"[0m  [["verb", "GET"], ["path", "/test_create"], ["response_code", 200], ["response_headers", "{\"Content-Type\":\"application/json\"}"], ["response_body", "{ \"value\": \"Some value\" }"], ["created_at", "2024-10-08 09:41:20.399275"], ["updated_at", "2024-10-08 09:41:20.399275"]]
  ↳ app/services/create.rb:16:in `call'
  [1m[36mTRANSACTION (2.7ms)[0m  [1m[35mCOMMIT[0m
  ↳ app/services/create.rb:16:in `call'
  [1m[36mApiKey Load (0.2ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.6ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/serializers/endpoint.rb:7:in `represent'
  [1m[36mApiKey Load (0.2ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (1.6ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/test_create"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:48:in `block in <class:Root>'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/test_create"], ["verb", "GET"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:48:in `block in <class:Root>'
  [1m[36mApiKey Load (0.2ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mApiKey Load (0.2ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."id" = $1 LIMIT $2[0m  [["id", 3], ["LIMIT", 1]]
  ↳ app/services/delete_endpoint_actor.rb:9:in `call'
  [1m[36mTRANSACTION (0.1ms)[0m  [1m[35mBEGIN[0m
  ↳ app/services/delete_endpoint_actor.rb:11:in `call'
  [1m[36mEndpoint Destroy (0.2ms)[0m  [1m[31mDELETE FROM "endpoints" WHERE "endpoints"."id" = $1[0m  [["id", 3]]
  ↳ app/services/delete_endpoint_actor.rb:11:in `call'
  [1m[36mTRANSACTION (1.5ms)[0m  [1m[35mCOMMIT[0m
  ↳ app/services/delete_endpoint_actor.rb:11:in `call'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.9ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/serializers/endpoint.rb:7:in `represent'
  [1m[36mApiKey Load (0.5ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.5ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."id" = $1 LIMIT $2[0m  [["id", 4], ["LIMIT", 1]]
  ↳ app/services/delete_endpoint_actor.rb:9:in `call'
  [1m[36mTRANSACTION (0.4ms)[0m  [1m[35mBEGIN[0m
  ↳ app/services/delete_endpoint_actor.rb:11:in `call'
  [1m[36mEndpoint Destroy (0.6ms)[0m  [1m[31mDELETE FROM "endpoints" WHERE "endpoints"."id" = $1[0m  [["id", 4]]
  ↳ app/services/delete_endpoint_actor.rb:11:in `call'
  [1m[36mTRANSACTION (0.6ms)[0m  [1m[35mCOMMIT[0m
  ↳ app/services/delete_endpoint_actor.rb:11:in `call'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/serializers/endpoint.rb:7:in `represent'
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.9ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mApiKey Load (1.0ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.5ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/endpoints/:id"], ["verb", "PATCH"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:48:in `block in <class:Root>'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."id" = $1 LIMIT $2[0m  [["id", 6], ["LIMIT", 1]]
  ↳ app/services/update_service.rb:33:in `find_endpoint'
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mBEGIN[0m
  ↳ app/services/update_service.rb:39:in `update_endpoint'
  [1m[36mEndpoint Load (0.4ms)[0m  [1m[37mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."id" = $1 LIMIT $2 FOR UPDATE[0m  [["id", 6], ["LIMIT", 1]]
  ↳ app/services/update_service.rb:39:in `update_endpoint'
  [1m[36mEndpoint Exists? (0.2ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."id" != $2 LIMIT $3[0m  [["path", "/test_create"], ["id", 6], ["LIMIT", 1]]
  ↳ app/services/update_service.rb:40:in `block in update_endpoint'
  [1m[36mEndpoint Update (0.5ms)[0m  [1m[33mUPDATE "endpoints" SET "verb" = $1, "response_code" = $2, "response_body" = $3, "updated_at" = $4 WHERE "endpoints"."id" = $5[0m  [["verb", "POST"], ["response_code", 201], ["response_body", "{ \"message\": \"Hello, everyone!\" }"], ["updated_at", "2024-10-08 09:53:10.919553"], ["id", 6]]
  ↳ app/services/update_service.rb:40:in `block in update_endpoint'
  [1m[36mTRANSACTION (1.0ms)[0m  [1m[35mCOMMIT[0m
  ↳ app/services/update_service.rb:39:in `update_endpoint'
  [1m[36mApiKey Load (0.5ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/serializers/endpoint.rb:7:in `represent'
  [1m[36mApiKey Load (0.4ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.7ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."verb" = $2 LIMIT $3[0m  [["path", "/test_create"], ["verb", "POST"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:48:in `block in <class:Root>'
  [1m[36mApiKey Load (1.0ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (4.6ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints"[0m
  ↳ app/api/serializers/endpoint.rb:7:in `represent'
  [1m[36mApiKey Load (1.8ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mApiKey Load (0.5ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:19:in `valid_api_key?'
  [1m[36mEndpoint Load (0.6ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."id" = $1 LIMIT $2[0m  [["id", 76], ["LIMIT", 1]]
  ↳ app/services/update_service.rb:33:in `find_endpoint'
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (1.0ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mApiKey Load (0.6ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:18:in `valid_api_key?'
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.9ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
  [1m[36mApiKey Load (0.8ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:18:in `valid_api_key?'
  [1m[36mApiKey Load (3.7ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:18:in `valid_api_key?'
  [1m[36mApiKey Load (4.6ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:18:in `valid_api_key?'
  [1m[36mApiKey Load (0.3ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:18:in `valid_api_key?'
  [1m[36mEndpoint Load (0.6ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."id" = $1 LIMIT $2[0m  [["id", 6], ["LIMIT", 1]]
  ↳ app/services/patch.rb:33:in `find_endpoint'
  [1m[36mTRANSACTION (0.2ms)[0m  [1m[35mBEGIN[0m
  ↳ app/services/patch.rb:39:in `update_endpoint'
  [1m[36mEndpoint Load (0.9ms)[0m  [1m[37mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."id" = $1 LIMIT $2 FOR UPDATE[0m  [["id", 6], ["LIMIT", 1]]
  ↳ app/services/patch.rb:39:in `update_endpoint'
  [1m[36mEndpoint Exists? (0.4ms)[0m  [1m[34mSELECT 1 AS one FROM "endpoints" WHERE "endpoints"."path" = $1 AND "endpoints"."id" != $2 LIMIT $3[0m  [["path", "/test_create"], ["id", 6], ["LIMIT", 1]]
  ↳ app/services/patch.rb:40:in `block in update_endpoint'
  [1m[36mTRANSACTION (0.9ms)[0m  [1m[35mCOMMIT[0m
  ↳ app/services/patch.rb:39:in `update_endpoint'
  [1m[36mApiKey Load (0.5ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:18:in `valid_api_key?'
  [1m[36mApiKey Load (0.4ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" = $1 LIMIT $2[0m  [["access_token", "7a58bed399beccc64e6c6b6798dc42445d211163"], ["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:18:in `valid_api_key?'
  [1m[36mEndpoint Load (0.3ms)[0m  [1m[34mSELECT "endpoints".* FROM "endpoints" WHERE "endpoints"."id" = $1 LIMIT $2[0m  [["id", 46], ["LIMIT", 1]]
  ↳ app/services/delete.rb:9:in `call'
  [1m[36mApiKey Load (0.9ms)[0m  [1m[34mSELECT "api_keys".* FROM "api_keys" WHERE "api_keys"."access_token" IS NULL LIMIT $1[0m  [["LIMIT", 1]]
  ↳ app/api/endpoints/root.rb:18:in `valid_api_key?'
DEPRECATION WARNING: Initialization autoloaded the constants Constants and Constants::Endpoints.

Being able to do this is deprecated. Autoloading during initialization is going
to be an error condition in future versions of Rails.

Reloading does not reboot the application, and therefore code executed during
initialization does not run again. So, if you reload Constants, for example,
the expected changes won't be reflected in that stale Module object.

These autoloaded constants have been unloaded.

In order to autoload safely at boot time, please wrap your code in a reloader
callback this way:

    Rails.application.reloader.to_prepare do
      # Autoload classes and modules needed at boot time here.
    end

That block runs when the application boots, and every time there is a reload.
For historical reasons, it may run twice, so it has to be idempotent.

Check the "Autoloading and Reloading Constants" guide to learn more about how
Rails autoloads and reloads.
 (called from <main> at /Users/hannabautsiuk/Documents/Work/Tech challenges/babel/echo_server/config/environment.rb:5)
  [1m[35m (0.7ms)[0m  [1m[34mSELECT "schema_migrations"."version" FROM "schema_migrations" ORDER BY "schema_migrations"."version" ASC[0m
